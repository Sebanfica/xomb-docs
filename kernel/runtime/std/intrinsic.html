<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>std.intrinsic</title>
        </head><body>
        <h1>std.intrinsic</h1>
        <!-- Generated by Ddoc from ../kernel/runtime/std/intrinsic.d -->
These functions are built-in intrinsics to the compiler.
<br><br>
Intrinsic functions are functions built in to the compiler,
	usually to take advantage of specific CPU features that
	are inefficient to handle via external functions.
	The compiler's optimizer and code generator are fully
	integrated in with <u>intrinsic</u> functions, bringing to bear
	their full power on them.
	This can result in some surprising speedups.
<br><br>

<dl><dt><big>int <u>bsf</u>(uint <i>v</i>);
</big></dt>
<dd>Scans the bits in <i>v</i> starting with bit 0, looking
 for the first set bit.
<br><br>
<b>Returns:</b><br>
The bit number of the first bit set.
	The return value is undefined if <i>v</i> is zero.<br><br>

</dd>
<dt><big>int <u>bsr</u>(uint <i>v</i>);
</big></dt>
<dd>Scans the bits in <i>v</i> from the most significant bit
 to the least significant bit, looking
 for the first set bit.
<br><br>
<b>Returns:</b><br>
The bit number of the first bit set.
	The return value is undefined if <i>v</i> is zero.
<br><br>
<b>Example:</b><br>
<pre class="d_code"> <font color=blue>import</font> std.intrinsic;

 <font color=blue>int</font> main()
 {
     <font color=blue>uint</font> <i>v</i>;
     <font color=blue>int</font> x;

     <i>v</i> = 0x21;
     x = bsf(<i>v</i>);
     printf(<font color=red>"bsf(x%x) = %d\n"</font>, <i>v</i>, x);
     x = <u>bsr</u>(<i>v</i>);
     printf(<font color=red>"bsr(x%x) = %d\n"</font>, <i>v</i>, x);
     <font color=blue>return</font> 0;
 }
</pre>
<br><br>
<b>Output:</b><br>
bsf(x21) = 0<br>
  <u>bsr</u>(x21) = 5<br><br>

</dd>
<dt><big>int <u>bt</u>(uint* <i>p</i>, uint <i>bitnum</i>);
</big></dt>
<dd>Tests the bit.<br><br>

</dd>
<dt><big>int <u>btc</u>(uint* <i>p</i>, uint <i>bitnum</i>);
</big></dt>
<dd>Tests and complements the bit.<br><br>

</dd>
<dt><big>int <u>btr</u>(uint* <i>p</i>, uint <i>bitnum</i>);
</big></dt>
<dd>Tests and resets (sets to 0) the bit.<br><br>

</dd>
<dt><big>int <u>bts</u>(uint* <i>p</i>, uint <i>bitnum</i>);
</big></dt>
<dd>Tests and sets the bit.
<br><br>
<b>Params:</b><br>
<table><tr><td>uint* <i>p</i></td>
<td>a non-NULL pointer to an array of uints.</td></tr>
<tr><td>index</td>
<td>a bit number, starting with bit 0 of <i>p</i>[0],
 and progressing. It addresses bits like the expression:
<pre class="d_code"><i>p</i>[index / (<font color=blue>uint</font>.sizeof*8)] &amp; (1 &lt;&lt; (index &amp; ((<font color=blue>uint</font>.sizeof*8) - 1)))
</pre>
</td></tr>
</table><br>
<b>Returns:</b><br>
A non-zero value if the bit was set, and a zero
	if it was clear.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>import</font> std.intrinsic;

<font color=blue>int</font> main()
{
    <font color=blue>uint</font> array[2];

    array[0] = 2;
    array[1] = 0x100;

    printf(<font color=red>"btc(array, 35) = %d\n"</font>, &lt;b&gt;btc&lt;/b&gt;(array, 35));
    printf(<font color=red>"array = [0]:x%x, [1]:x%x\n"</font>, array[0], array[1]);

    printf(<font color=red>"btc(array, 35) = %d\n"</font>, &lt;b&gt;btc&lt;/b&gt;(array, 35));
    printf(<font color=red>"array = [0]:x%x, [1]:x%x\n"</font>, array[0], array[1]);

    printf(<font color=red>"bts(array, 35) = %d\n"</font>, &lt;b&gt;<u>bts</u>&lt;/b&gt;(array, 35));
    printf(<font color=red>"array = [0]:x%x, [1]:x%x\n"</font>, array[0], array[1]);

    printf(<font color=red>"btr(array, 35) = %d\n"</font>, &lt;b&gt;btr&lt;/b&gt;(array, 35));
    printf(<font color=red>"array = [0]:x%x, [1]:x%x\n"</font>, array[0], array[1]);

    printf(<font color=red>"bt(array, 1) = %d\n"</font>, &lt;b&gt;bt&lt;/b&gt;(array, 1));
    printf(<font color=red>"array = [0]:x%x, [1]:x%x\n"</font>, array[0], array[1]);

    <font color=blue>return</font> 0;
}
</pre>
<br><br>
<b>Output:</b><br>
<pre>
btc(array, 35) = 0
array = [0]:x2, [1]:x108
btc(array, 35) = -1
array = [0]:x2, [1]:x100
<u>bts</u>(array, 35) = 0
array = [0]:x2, [1]:x108
btr(array, 35) = -1
array = [0]:x2, [1]:x100
bt(array, 1) = -1
array = [0]:x2, [1]:x100
</pre><br><br>

</dd>
<dt><big>uint <u>bswap</u>(uint <i>v</i>);
</big></dt>
<dd>Swaps bytes in a 4 byte uint end-to-end, i.e. byte 0 becomes
	byte 3, byte 1 becomes byte 2, byte 2 becomes byte 1, byte 3
	becomes byte 0.<br><br>

</dd>
<dt><big>ubyte <u>inp</u>(uint <i>port_address</i>);
<br>ushort <u>inpw</u>(uint <i>port_address</i>);
<br>uint <u>inpl</u>(uint <i>port_address</i>);
</big></dt>
<dd>Reads I/O port at <i>port_address</i>.<br><br>

</dd>
<dt><big>ubyte <u>outp</u>(uint <i>port_address</i>, ubyte <i>value</i>);
<br>ushort <u>outpw</u>(uint <i>port_address</i>, ushort <i>value</i>);
<br>uint <u>outpl</u>(uint <i>port_address</i>, uint <i>value</i>);
</big></dt>
<dd>Writes and returns <i>value</i> to I/O port at <i>port_address</i>.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://www.digitalmars.com/d/1.0/ddoc.html">Ddoc</a>. </small>
        </body></html>
